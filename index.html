<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DocSleuth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google Fonts for a modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Load PDF.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  <!-- Load Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <!-- Load GPT tokenizer library -->
  <script src="https://unpkg.com/gpt-tokenizer"></script>
  <!-- Load jsPDF (not used because only Word download is enabled) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Global Reset & Fonts */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0b0c10, #1f2833);
      color: #333;
      overflow-x: hidden;
      position: relative;
      padding-bottom: 50px;
    }
    /* Starry background overlay */
    body::before {
      content: "";
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='1' fill='white'/></svg>") repeat;
      opacity: 0.3;
      animation: starryNight 100s linear infinite;
      z-index: -2;
    }
    @keyframes starryNight {
      from { background-position: 0 0; }
      to { background-position: -1000px -1000px; }
    }
    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #001f3f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-content {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: modalIn 0.5s ease-out;
      border: 2px solid #fff;
    }
    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes modalOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .closing { animation: modalOut 0.3s ease-in forwards; }
    .modal-content input {
      width: 100%; padding: 10px; margin: 10px 0; font-size: 16px;
    }
    .disclaimer { font-size: 14px; color: #666; margin-bottom: 10px; }
    /* Header Styles */
    header {
      position: relative;
      text-align: center;
      padding: 20px 10px;
      background: inherit;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      overflow: hidden;
      height: 80px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-bottom: 20px;
    }
    header h1 {
      font-size: 32px; margin: 0;
      animation: zoomInOut 5s infinite;
      position: relative; z-index: 1;
    }
    @keyframes zoomInOut {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    #header-subtitle {
      font-size: 16px;
      margin-top: 5px;
      font-style: italic;
      color: #e0e0e0;
      position: relative;
      z-index: 1;
      height: 20px;
    }
    /* Front Page Wrapper */
    #front-page-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #main-page {
      max-width: 600px;
      margin: 0 auto;
    }
    /* Drag & Drop Area modifications */
    #drop-area {
      border: 2px dashed rgba(255,255,255,0.5);
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      background: transparent !important;
      transition: background 0.3s, border-color 0.3s;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #drop-area p { font-size: 18px; margin-bottom: 20px; color: #fff; }
    #drop-area:hover { background: transparent !important; }
    /* White border for buttons */
    #drop-area .btn, #summary-page .btn {
      border: 2px solid #fff;
    }
    /* File List and other elements remain unchanged */
    #file-list { margin-top: 20px; }
    .file-item {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px 20px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: transform 0.2s;
      position: relative;
    }
    .file-item:hover { transform: translateY(-2px); }
    .file-item .icon { font-size: 50px; }
    .file-details { flex: 1; }
    .file-details p { margin: 3px 0; font-size: 15px; }
    .progress-container {
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin: 10px 0;
      height: 20px;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #001f3f, #555);
      text-align: center;
      color: #fff;
      line-height: 20px;
      transition: width 0.2s ease;
    }
    .remove-file {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 20px;
      color: #ff5722;
    }
    @keyframes removeAnimation {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5) rotate(45deg); }
    }
    .removing { animation: removeAnimation 0.5s forwards; }
    /* Button styles */
    .button-container { margin-top: 10px; }
    .btn {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
      margin-right: 5px;
    }
    .btn:hover { background-color: #003366; transform: scale(1.05); }
    .btn:disabled { background-color: #aaa; cursor: not-allowed; }
    /* Summary Page – using the entire page as container */
    #summary-page {
      display: none;
      background: transparent;
      padding: 20px 20px 0 20px;  /* Removed bottom padding */
      color: #fff;
      min-height: 100vh;
      box-sizing: border-box;
      flex-direction: row;
      gap: 20px;
      position: relative;
    }
    /* When summary page is active it is a flex container */
    #summary-page.flex {
      display: flex;
    }
    /* Back Button – positioned at top left and no overlap with content */
    #back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 12px;
      font-size: 14px;
      z-index: 1001;
    }
    /* Summary columns: fixed height to fill viewport */
    .summary-left {
      flex: 1;
      height: calc(100vh - 80px);
      overflow-y: auto;
      padding: 70px 10px 10px 10px;
    }
    .summary-right {
      flex: 1;
      height: calc(100vh - 80px);
      position: relative;
    }
    /* PDF viewer wrapper: remove extra top padding */
    #pdf-viewer-wrapper {
      max-height: 100%;
      overflow-y: auto;
      position: relative;
      padding-top: 0;
    }
    /* White separation line between summary sections */
    .summary-left .section:not(:last-child) {
      border-bottom: 1px solid #fff;
      padding-bottom: 20px;
      margin-bottom: 20px;
    }
    /* Page link styling: white text */
    .page-link {
      color: #fff;
      text-decoration: underline;
      cursor: pointer;
    }
    .page-link:hover { color: #f0f0f0; }
    /* Fade-in Animation for page transitions */
    @keyframes fadeInPage {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .fade-in {
      animation: fadeInPage 0.6s ease-out;
    }
    /* Fade-out Animation for back transition */
    @keyframes fadeOutPage {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    .fade-out {
      animation: fadeOutPage 0.3s ease-out forwards;
    }
    /* Chatbot Styles (unchanged except z-index bump for the toggle) */
    .chatbot-container {
      width: 350px;
      max-height: 500px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      resize: both;
      overflow: auto;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      position: fixed;
      bottom: 70px;
      right: 20px;
    }
    .chatbot-container.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .chatbot-drag-handle {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #001f3f;
      border-radius: 3px;
      cursor: nwse-resize;
      z-index: 1010;
    }
    .chatbot-header {
      background: #001f3f;
      color: #fff;
      padding: 10px 10px 10px 30px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    .chatbot-messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #f7f7f7;
    }
    .chatbot-input-container {
      display: flex;
      border-top: 1px solid #e0e0e0;
    }
    .chatbot-input-container input {
      flex: 1;
      border: none;
      padding: 10px;
      font-size: 16px;
    }
    .chatbot-input-container button {
      border: none;
      background: #001f3f;
      color: #fff;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
    }
    .chatbot-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.7);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 3000;
      transition: transform 0.2s ease;
    }
    .chatbot-toggle:active { transform: scale(0.9); }
    .chatbot-message {
      margin-bottom: 5px;
      padding: 8px;
      border-radius: 5px;
      max-width: 80%;
      font-size: 16px;
    }
    .chatbot-message.user {
      background: #001f3f;
      color: #fff;
      align-self: flex-end;
    }
    .chatbot-message.bot {
      background: #eee;
      color: #333;
      align-self: flex-start;
    }
    .chatbot-message.typing { font-style: italic; color: #999; }
    /* Info Button Styles */
    #info-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.5);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 3000;
    }
    #drop-area.highlight {
      background: rgba(255, 255, 255, 0.1);
      border-color: #fff;
      transform: scale(1.02);
      transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="token-modal" class="modal">
    <div class="modal-content">
      <h2>Enter your OpenAI API Key</h2>
      <p class="disclaimer">We DO NOT collect or store your key.</p>
      <input type="text" id="open-token-input" placeholder="Paste your OpenAI API Key here...">
      <p class="disclaimer">
        <a href="https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key" target="_blank">
          Where do I find my OpenAI API Key?
        </a>
      </p>
      <button id="open-token-submit" class="btn">Submit</button>
      <p id="token-error" style="color:red; display:none;"></p>
    </div>
  </div>

  <!-- Info Modal -->
  <div id="info-modal" class="modal">
    <div class="modal-content">
      <h2>About DocSleuth</h2>
      <p>DocSleuth is a powerful tool that extracts text from PDF documents using advanced OCR technology and then generates detailed, structured summaries with AI. It helps you quickly uncover insights, analyze content, and interact with your documents—all while ensuring your privacy. You can also chat with the AI about your document.</p>
      <p>We do not collect any user data.</p>
      <p>© 2025 Frederick Liu. All rights reserved.</p>
      <button id="info-close" class="btn">Close</button>
    </div>
  </div>

  <!-- Info Button -->
  <div id="info-button">i</div>

  <!-- Front Page Wrapper -->
  <div id="front-page-wrapper">
    <header>
      <h1>DocSleuth</h1>
      <p id="header-subtitle">Uncover insights effortlessly</p>
    </header>

    <!-- Summary Page – used as the whole page container when active -->
    <div class="container" id="summary-page"></div>

    <!-- Main Page -->
    <div class="container" id="main-page">
      <div id="drop-area">
        <p>Drag &amp; drop your PDF files here</p>
        <button id="fileSelect" class="btn">Select Files</button>
        <input type="file" id="fileElem" multiple accept="application/pdf" style="display:none;">
      </div>
      <div id="file-list"></div>
    </div>
  </div>

  <script>
    // Global variable for the token.
    let OPENAI_API_KEY = "";
    
    /********************************************************************
     * Token Validation and Modal Handling
     ********************************************************************/
    async function validateToken(token) {
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: { "Authorization": "Bearer " + token }
        });
        return response.ok;
      } catch (error) { return false; }
    }
    
    window.addEventListener("load", () => {
      const savedToken = sessionStorage.getItem("openToken");
      if (savedToken) { OPENAI_API_KEY = savedToken; }
      else { document.getElementById("token-modal").style.display = "flex"; }
      startTypingAnimation(); // start header subtitle animation
    });
    
    document.getElementById("open-token-submit").addEventListener("click", async function(){
      const tokenInput = document.getElementById("open-token-input");
      const token = tokenInput.value.trim();
      const errorMsg = document.getElementById("token-error");
      if (token === "") {
        errorMsg.textContent = "API Key cannot be empty.";
        errorMsg.style.display = "block";
        return;
      }
      const isValid = await validateToken(token);
      if (isValid) {
        const modalContent = document.querySelector("#token-modal .modal-content");
        modalContent.classList.add("closing");
        modalContent.addEventListener("animationend", function handler() {
          document.getElementById("token-modal").style.display = "none";
          modalContent.classList.remove("closing");
          modalContent.removeEventListener("animationend", handler);
        });
        OPENAI_API_KEY = token;
        sessionStorage.setItem("openToken", token);
      } else {
        errorMsg.textContent = "Invalid API Key. Please try again.";
        errorMsg.style.display = "block";
      }
    });

    // Info Modal handling with animated close
    document.getElementById("info-button").addEventListener("click", () => {
      document.getElementById("info-modal").style.display = "flex";
    });
    document.getElementById("info-close").addEventListener("click", () => {
      const infoModalContent = document.querySelector("#info-modal .modal-content");
      infoModalContent.classList.add("closing");
      infoModalContent.addEventListener("animationend", function handler() {
        document.getElementById("info-modal").style.display = "none";
        infoModalContent.classList.remove("closing");
        infoModalContent.removeEventListener("animationend", handler);
      });
    });
    
    /********************************************************************
     * Typing Animation for Header Subtitle
     ********************************************************************/
    function startTypingAnimation() {
      const element = document.getElementById("header-subtitle");
      const fullText = element.textContent;
      let charIndex = 0;
      let typing = true;
      function type() {
        if (typing) {
          charIndex++;
          if (charIndex > fullText.length) { typing = false; setTimeout(type, 1000); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 100); }
        } else {
          charIndex--;
          if (charIndex < 0) { typing = true; setTimeout(type, 500); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 50); }
        }
      }
      type();
    }
    
    /********************************************************************
     * Tokenizer Setup
     ********************************************************************/
    let encode;
    if (typeof GPTTokenizer_cl100k_base !== "undefined" && GPTTokenizer_cl100k_base.encode) {
      encode = GPTTokenizer_cl100k_base.encode;
    } else { encode = function(text) { return text.split(/\s+/); }; }
    
    /********************************************************************
     * Text Preprocessing Helper
     ********************************************************************/
    function preprocessText(text) {
      return text.replace(/\s+/g, ' ').trim();
    }
    
    /********************************************************************
     * Global DOM Elements and Variables
     ********************************************************************/
    const dropArea = document.getElementById('drop-area');
    const fileElem = document.getElementById('fileElem');
    const fileSelect = document.getElementById('fileSelect');
    const fileList = document.getElementById('file-list');
    const mainPage = document.getElementById('main-page');
    const summaryPage = document.getElementById('summary-page');
    const filesData = {};
    let pdfScale = 1.2;
    let currentDocumentOriginalText = "";
    let chatMemory = [];
    
    /********************************************************************
     * File Selection and Drag & Drop Event Listeners
     ********************************************************************/
    fileSelect.addEventListener('click', () => fileElem.click());
    fileElem.addEventListener('change', handleFiles);
    dropArea.addEventListener('dragover', function(e) {
      e.preventDefault();
      dropArea.classList.add('highlight');
    });
    dropArea.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dropArea.classList.remove('highlight');
    });
    dropArea.addEventListener('drop', function(e) {
      e.preventDefault();
      dropArea.classList.remove('highlight');
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        handleFiles({ target: { files: files } });
      }
    });
    
    /********************************************************************
     * Dynamic Progress Bar Animation
     ********************************************************************/
    function updateProgress(fileId, target) {
      const progressBar = document.getElementById('progress-' + fileId);
      if (!progressBar) return;
      let current = parseInt(progressBar.textContent) || 0;
      const interval = setInterval(() => {
        if (current < target) {
          current++;
          progressBar.style.width = current + "%";
          progressBar.textContent = current + "%";
        } else { clearInterval(interval); }
      }, 20);
    }
    
    /********************************************************************
     * File Processing: Create file item with button container
     ********************************************************************/
    function handleFiles(e) {
      const files = e.target.files;
      for (let file of files) {
        if (file.type !== "application/pdf") continue;
        processFile(file);
      }
    }
    
    function processFile(file) {
      const fileId = 'file-' + Math.random().toString(36).substr(2, 9);
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      fileItem.id = fileId;
      fileItem.innerHTML = `
        <span class="remove-file" title="Remove File">x</span>
        <div class="icon">📄</div>
        <div class="file-details">
          <p><strong>${file.name}</strong></p>
          <p>
            ${(file.size / 1024).toFixed(2)} KB
            <span class="token-info" id="token-info-${fileId}" style="font-size: 12px; color: #555; margin-left: 10px;">
              Tokens: 0 | Cost: $0.00
            </span>
          </p>
          <div class="progress-container">
            <div class="progress-bar" id="progress-${fileId}">0%</div>
          </div>
          <div class="button-container">
            <button id="submit-btn-${fileId}" class="btn">Evaluate</button>
            <button id="proceed-btn-${fileId}" class="btn" style="display:none;">Proceed</button>
            <button id="summary-btn-${fileId}" class="btn" style="display:none;">View Summary</button>
          </div>
        </div>
      `;
      fileList.appendChild(fileItem);
      
      const removeIcon = fileItem.querySelector('.remove-file');
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        fileItem.classList.add("removing");
        fileItem.addEventListener("animationend", () => {
          if(fileList.contains(fileItem)) { fileList.removeChild(fileItem); }
          delete filesData[fileId];
        });
      });
      
      const submitBtn = document.getElementById(`submit-btn-${fileId}`);
      submitBtn.addEventListener('click', () => {
        submitBtn.style.display = 'none';
        summarizePDF(file, fileId);
      });
    }
    
    /********************************************************************
     * PDF Extraction & OCR Functions
     ********************************************************************/
    async function extractPDFText(file) {
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const hasTwoColumns = await detectTwoColumns(canvas, context);
        let pageText = "";
        if (hasTwoColumns) {
          const leftCanvas = document.createElement("canvas");
          leftCanvas.width = Math.floor(canvas.width / 2);
          leftCanvas.height = canvas.height;
          const leftCtx = leftCanvas.getContext("2d");
          leftCtx.drawImage(canvas, 0, 0, leftCanvas.width, leftCanvas.height);
          const rightCanvas = document.createElement("canvas");
          rightCanvas.width = Math.ceil(canvas.width / 2);
          rightCanvas.height = canvas.height;
          const rightCtx = rightCanvas.getContext("2d");
          rightCtx.drawImage(canvas, leftCanvas.width, 0, rightCanvas.width, rightCanvas.height);
          const leftText = await performOCR(leftCanvas);
          const rightText = await performOCR(rightCanvas);
          pageText = leftText + "\n" + rightText;
        } else {
          pageText = await performOCR(canvas);
        }
        fullText += pageText + "\n";
      }
      return fullText;
    }
    
    async function detectTwoColumns(canvas, context) {
      const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const textPixelThreshold = 200;
      const nonWhitePixelCount = (xStart, xEnd) => {
        let count = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = xStart; x < xEnd; x++) {
            const index = (y * canvas.width + x) * 4;
            const brightness = (data[index] + data[index+1] + data[index+2]) / 3;
            if (brightness < textPixelThreshold) count++;
          }
        }
        return count;
      };
      const midX = Math.floor(canvas.width / 2);
      const leftCount = nonWhitePixelCount(0, midX);
      const rightCount = nonWhitePixelCount(midX, canvas.width);
      const ratio = leftCount / rightCount;
      const minCount = 10000, maxRatio = 1.5;
      return (leftCount > minCount && rightCount > minCount && ratio > (1/maxRatio) && ratio < maxRatio);
    }
    
    async function performOCR(canvas) {
      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng', { logger: m => m });
        return text;
      } catch (error) {
        console.error("OCR Error:", error);
        return "";
      }
    }
    
    /********************************************************************
     * Summarization & JSON Parsing
     ********************************************************************/
    async function summarizePDF(file, fileId) {
      const progressBar = document.getElementById('progress-' + fileId);
      const summaryBtn = document.getElementById('summary-btn-' + fileId);
      const fileItem = document.getElementById(fileId);
      const buttonContainer = fileItem.querySelector('.button-container');
      
      let initialSpinner = document.createElement("div");
      initialSpinner.className = "spinner";
      buttonContainer.appendChild(initialSpinner);
      
      try {
        updateProgress(fileId, 20);
        const pdfText = await extractPDFText(file);
        updateProgress(fileId, 40);
        
        const cleanedText = preprocessText(pdfText);
        const tokenCount = encode(cleanedText).length;
        if (tokenCount > 200000) {
          const errorMsg = document.createElement("p");
          errorMsg.style.color = "red";
          errorMsg.textContent = "Unable to process file due to large token count.";
          fileItem.appendChild(errorMsg);
          initialSpinner.remove();
          return;
        }
        
        const tokenCost = ((tokenCount / 1000000) * 1.10).toFixed(2);
        document.getElementById(`token-info-${fileId}`).innerText = `Tokens: ${tokenCount} | Cost: $${tokenCost}`;
        
        filesData[fileId] = { file: file, originalText: cleanedText };
        
        initialSpinner.remove();
    
        let proceedBtn = document.getElementById(`proceed-btn-${fileId}`);
        summaryBtn.style.display = "none";
        proceedBtn.style.display = "inline-block";
    
        proceedBtn.addEventListener("click", async function onProceed() {
          proceedBtn.style.display = "none";
          proceedBtn.removeEventListener("click", onProceed);
          let proceedSpinner = document.createElement("div");
          proceedSpinner.className = "spinner";
          buttonContainer.appendChild(proceedSpinner);
    
          const prompt = `Generate an extremely detailed, structured summary of the following PDF content. Divide the summary into multiple sections; if a section is large, subdivide it into subsections. If the original document contains clearly labeled section headers or sub-headers (for example, "Introduction", "Literature Review", etc.), organize the summary according to those headers. For each section or subsection, include a header, well-formatted content (using bullet points, paragraphs, etc.), and a "page" field indicating the approximate page number from the original PDF where that content appears (except for the Analysis section). Output the summary as valid JSON strictly following this format (and nothing else):

{
  "title": "Summary of ${file.name}",
  "sections": [
    { "header": "Section Header", "content": "Section Content", "page": 1 },
    { "header": "Section Header with Subsections", "content": "Main content summary", "subsections": [
         { "header": "Subsection Header", "content": "Subsection Content", "page": 3 },
         ... additional subsections ...
       ]
    },
    { "header": "Analysis", "content": "Your two paragraph analysis here." }
  ]
}

Replace the placeholder texts with appropriate values based on the PDF content.

PDF Content:
${cleanedText}`;
    
          updateProgress(fileId, 60);
    
          const totalTokenLimit = 200000;
          const promptTokens = encode(prompt).length;
          const bufferTokens = 100;
          const computedCompletionTokens = totalTokenLimit - promptTokens - bufferTokens;
          const maxCompletionTokens = computedCompletionTokens > 1000 ? Math.min(computedCompletionTokens, 100000) : 1000;
    
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${OPENAI_API_KEY}`
            },
            body: JSON.stringify({
              model: "o3-mini",
              messages: [{ role: "user", content: prompt }],
              max_completion_tokens: maxCompletionTokens
            })
          });
    
          updateProgress(fileId, 80);
          if (!response.ok) {
            proceedSpinner.remove();
            const errorMsg = document.createElement("p");
            errorMsg.style.color = "red";
            errorMsg.textContent = "OpenAI API error: " + response.statusText;
            fileItem.appendChild(errorMsg);
            return;
          }
          const data = await response.json();
          const summaryOutput = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
            ? data.choices[0].message.content.trim() : null;
          let structuredSummary;
          try {
            structuredSummary = JSON.parse(summaryOutput);
          } catch (e) {
            structuredSummary = {
              title: `Summary of ${file.name}`,
              sections: [
                { header: "Summary", content: summaryOutput || "No summary was generated.", page: 1 }
              ]
            };
          }
          updateProgress(fileId, 100);
          filesData[fileId].summary = structuredSummary;
    
          proceedSpinner.remove();
          summaryBtn.style.display = "inline-block";
          summaryBtn.disabled = false;
          summaryBtn.addEventListener('click', () => showSummaryPage(fileId));
        });
      } catch (error) {
        console.error("Error processing PDF:", error);
        progressBar.style.background = "red";
        summaryBtn.textContent = "Error Summarizing";
      }
    }
    
    /********************************************************************
     * PDF Rendering & Gesture-Based Zoom Controls
     ********************************************************************/
    async function renderPDFPages(file, container, scale) {
      container.innerHTML = "";
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: scale });
        const canvas = document.createElement("canvas");
        canvas.id = "pdf-page-" + i;
        canvas.style.marginBottom = "10px";
        canvas.style.transition = "transform 0.3s ease";
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext("2d");
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        container.appendChild(canvas);
      }
    }
    
    function navigateToPage(page) {
      const target = document.getElementById('pdf-page-' + page);
      if (target) target.scrollIntoView({ behavior: "smooth" });
      else alert("Page " + page + " not found.");
    }
    
    /********************************************************************
     * Content Formatting Helpers
     ********************************************************************/
    function formatContent(text) {
      if (!text) return "";
      const lines = text.split('\n');
      let html = '';
      let listOpen = false;
      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('- ') || line.startsWith('• ')) {
          if (!listOpen) { html += '<ul>'; listOpen = true; }
          let item = line.substring(2).trim();
          html += `<li>${item}</li>`;
        } else {
          if (listOpen) { html += '</ul>'; listOpen = false; }
          if (line) { html += `<p>${line}</p>`; }
        }
      });
      if (listOpen) { html += '</ul>'; }
      return html;
    }
    
    function generateDetailedSummaryHTML(summary) {
      let html = `<h2>${summary.title}</h2>`;
      summary.sections.forEach((section, index) => {
        let toggle = "";
        if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
          toggle = `<span class="toggle-icon">▼</span>`;
        }
        html += `<div class="section" data-index="${index}">
          <h3>${toggle}${section.header}</h3>
          <div class="section-content">${formatContent(section.content)}</div>`;
        if (section.header.toLowerCase() !== "analysis" && section.page && (!section.subsections || section.subsections.length === 0)) {
          html += `<p><em>Approximate page: <a class="page-link" href="#" onclick="navigateToPage(${section.page}); return false;">${section.page}</a></em></p>`;
        }
        if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
          html += `<div class="subsections">`;
          section.subsections.forEach(subsection => {
            html += `<div class="subsection">
              <h4>${subsection.header}</h4>
              <div class="subsection-content">${formatContent(subsection.content)}</div>`;
            if (subsection.page) {
              html += `<p><em>Approximate page: <a class="page-link" href="#" onclick="navigateToPage(${subsection.page}); return false;">${subsection.page}</a></em></p>`;
            }
            html += `</div>`;
          });
          html += `</div>`;
        }
        html += `</div>`;
      });
      return html;
    }
    
    function generateWordDocumentHTML(summary) {
      let html = `
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${summary.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          h1, h2, h3, h4 { color: #001f3f; }
          h1 { font-size: 28px; text-align: center; margin-bottom: 20px; }
          h2 { font-size: 24px; margin-top: 20px; }
          h3 { font-size: 20px; margin-top: 15px; }
          h4 { font-size: 18px; margin-top: 10px; }
          p { font-size: 14px; line-height: 1.6; margin: 8px 0; }
          ul { margin: 10px 0 10px 20px; }
          .section { margin-bottom: 20px; }
          .subsections { margin-left: 20px; border-left: 2px solid #ccc; padding-left: 10px; }
          .analysis { background: #f0fff0; border: 1px solid #28a745; padding: 10px; }
        </style>
      </head>
      <body>
        <h1>${summary.title}</h1>
      `;
      summary.sections.forEach(section => {
        if (section.header.toLowerCase() === "analysis") {
          html += `<div class="section analysis">
                    <h2>${section.header}</h2>
                    ${formatContent(section.content)}
                  </div>`;
        } else {
          html += `<div class="section">
                    <h2>${section.header}</h2>
                    ${formatContent(section.content)}
                  `;
          if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
            html += `<div class="subsections">`;
            section.subsections.forEach(subsec => {
              html += `<div class="subsection">
                        <h3>${subsec.header}</h3>
                        ${formatContent(subsec.content)}
                      </div>`;
            });
            html += `</div>`;
          } else if (section.page) {
            html += `<p><em>Approximate page: ${section.page}</em></p>`;
          }
          html += `</div>`;
        }
      });
      html += `</body></html>`;
      return html;
    }
    
    function downloadFormattedSummary(summary, format) {
      let htmlContent = "";
      if (format === "word") { htmlContent = generateWordDocumentHTML(summary); }
      else { htmlContent = generateDetailedSummaryHTML(summary); }
      const blob = new Blob(['\ufeff', htmlContent], { type: 'application/msword' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = summary.title.replace(/\s+/g, '_') + ".doc";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    /********************************************************************
     * Display Summary and PDF Viewer (Full-page Flex Layout with Smooth Transitions)
     ********************************************************************/
    async function showSummaryPage(fileId) {
      const data = filesData[fileId];
      if (!data) return;
      // Hide header and info button for a cleaner summary page
      document.querySelector("header").style.display = "none";
      document.getElementById("info-button").style.display = "none";
      currentDocumentOriginalText = data.originalText;
      
      // Hide main page and build the summary page using the entire page as container
      mainPage.style.display = 'none';
      summaryPage.classList.add("flex");
      summaryPage.style.display = 'flex';
      summaryPage.innerHTML = `
        <button id="back-button" class="btn">← Back to Files</button>
        <div class="summary-left">
          ${generateDetailedSummaryHTML(data.summary)}
          <div class="summary-controls">
            <button id="download-word" class="btn">Download as Word</button>
          </div>
        </div>
        <div class="summary-right">
          <div id="pdf-viewer-wrapper">
            <div id="pdf-viewer-container"></div>
          </div>
        </div>
      `;
      summaryPage.classList.add("fade-in");
      setTimeout(() => { summaryPage.classList.remove("fade-in"); }, 600);
      
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');
      const pdfViewerWrapper = document.getElementById('pdf-viewer-wrapper');
      
      // Initial render of the PDF pages
      renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      
      // Set up gesture-based zooming for Mac/trackpad users:
      let initialScale = pdfScale;
      pdfViewerWrapper.addEventListener('gesturestart', function(e) {
        e.preventDefault();
        initialScale = pdfScale;
      });
      pdfViewerWrapper.addEventListener('gesturechange', function(e) {
        e.preventDefault();
        pdfScale = initialScale * e.scale;
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      
      // Also allow zooming via ctrl+wheel (common on many systems)
      pdfViewerWrapper.addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
          e.preventDefault();
          pdfScale += (e.deltaY < 0 ? 0.1 : -0.1);
          pdfScale = Math.max(0.1, pdfScale);
          renderPDFPages(data.file, pdfViewerContainer, pdfScale);
        }
      });
      
      document.querySelectorAll('.section').forEach(sectionElem => {
        const subsectionsDiv = sectionElem.querySelector('.subsections');
        if (subsectionsDiv) {
          const header = sectionElem.querySelector('h3, h2');
          header.style.cursor = "pointer";
          header.addEventListener('click', () => {
            subsectionsDiv.style.display = (subsectionsDiv.style.display === "none" ? "block" : "none");
          });
        }
      });
      
      setupDownloadButtons(data.summary);
      createChatbot();
      chatMemory = [];
    }
    
    function setupDownloadButtons(summary) {
      document.getElementById('download-word').onclick = () => { downloadFormattedSummary(summary, "word"); };
    }
    
    // Back button: immediately transition back to the main page without a blinking animation
    document.addEventListener('click', function(e) {
      if(e.target && e.target.id === 'back-button'){
        summaryPage.classList.add("fade-out");
        setTimeout(() => {
          summaryPage.style.display = 'none';
          mainPage.style.display = 'block';
          document.querySelector("header").style.display = "flex";
          document.getElementById("info-button").style.display = "flex";
          const chatbotToggle = document.getElementById('chatbot-toggle');
          const chatbotContainer = document.getElementById('chatbot-container');
          if (chatbotToggle) chatbotToggle.style.display = 'none';
          if (chatbotContainer) chatbotContainer.classList.remove("visible");
          summaryPage.classList.remove("fade-out");
        }, 300);
      }
    });
    
    /********************************************************************
     * Chatbot Implementation with Memory and Document Context
     ********************************************************************/
    function createChatbot() {
      let chatbotToggle = document.getElementById('chatbot-toggle');
      let chatbotContainer = document.getElementById('chatbot-container');
      if (!chatbotToggle) {
        chatbotToggle = document.createElement('div');
        chatbotToggle.id = "chatbot-toggle";
        chatbotToggle.className = "chatbot-toggle";
        chatbotToggle.innerHTML = "💬";
        document.body.appendChild(chatbotToggle);
      }
      if (!chatbotContainer) {
        chatbotContainer = document.createElement('div');
        chatbotContainer.id = "chatbot-container";
        chatbotContainer.className = "chatbot-container";
        chatbotContainer.innerHTML = `
          <div id="chatbot-drag-handle" class="chatbot-drag-handle"></div>
          <div id="chatbot-header" class="chatbot-header">Document Chat</div>
          <div id="chatbot-messages" class="chatbot-messages"></div>
          <div class="chatbot-input-container">
            <input type="text" id="chatbot-input" placeholder="Type your message...">
            <button id="chatbot-send" class="btn">Send</button>
          </div>
        `;
        document.body.appendChild(chatbotContainer);
        makeChatbotResizable();
      }
      chatbotContainer.classList.remove("visible");
      chatbotToggle.style.display = "flex";
      
      if (!chatbotToggle.dataset.listenerAdded) {
        chatbotToggle.addEventListener('click', () => {
          if (chatbotContainer.classList.contains("visible")) { chatbotContainer.classList.remove("visible"); }
          else { chatbotContainer.classList.add("visible"); }
        });
        chatbotToggle.dataset.listenerAdded = "true";
      }
      
      const sendButton = document.getElementById('chatbot-send');
      const inputField = document.getElementById('chatbot-input');
      if (!sendButton.dataset.listenerAdded) {
        sendButton.addEventListener('click', sendChatMessage);
        sendButton.dataset.listenerAdded = "true";
      }
      if (!inputField.dataset.listenerAdded) {
        inputField.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') sendChatMessage();
        });
        inputField.dataset.listenerAdded = "true";
      }
    }
    
    function makeChatbotResizable() {
      const handle = document.getElementById('chatbot-drag-handle');
      const container = document.getElementById('chatbot-container');
      handle.addEventListener('mousedown', initDrag);
      function initDrag(e) {
        e.preventDefault();
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
      }
      function doDrag(e) {
        const rect = container.getBoundingClientRect();
        const newWidth = rect.right - e.clientX;
        const newHeight = rect.bottom - e.clientY;
        if(newWidth > 200) { container.style.width = newWidth + 'px'; }
        if(newHeight > 150) { container.style.height = newHeight + 'px'; }
      }
      function stopDrag(e) {
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
      }
    }
    
    function appendChatMessage(sender, text, extraClass="") {
      const messagesContainer = document.getElementById('chatbot-messages');
      const messageElem = document.createElement('div');
      messageElem.classList.add('chatbot-message', sender);
      if (extraClass) messageElem.classList.add(extraClass);
      messageElem.textContent = text;
      messagesContainer.appendChild(messageElem);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return messageElem;
    }
    
    function typeOutText(element, text, interval) {
      let index = 0;
      const timer = setInterval(() => {
        if (index < text.length) { element.textContent += text.charAt(index); index++; }
        else { clearInterval(timer); }
      }, interval);
    }
    
    async function sendChatMessage() {
      const inputElem = document.getElementById('chatbot-input');
      const message = inputElem.value.trim();
      if (!message) return;
      appendChatMessage("user", message);
      inputElem.value = "";
      
      chatMemory.push({ role: "user", content: message });
      if (chatMemory.length > 50) { chatMemory.shift(); }
      
      let contextText = currentDocumentOriginalText;
      
      const conversation = [
        { role: "system", content: "You are an AI assistant that only responds based on the following document (do not include any external information):\n" + contextText }
      ].concat(chatMemory);
      
      const totalTokenLimit = 200000;
      let conversationContent = conversation.map(msg => msg.content).join(" ");
      const conversationTokens = encode(conversationContent).length;
      const bufferTokens = 100;
      const computed = totalTokenLimit - conversationTokens - bufferTokens;
      const maxCompletionTokens = computed > 1000 ? Math.min(computed, 100000) : 1000;
      
      const typingElem = appendChatMessage("bot", "DocSleuth is thinking...", "typing");
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
             "Content-Type": "application/json",
             "Authorization": `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: "o3-mini",
            messages: conversation,
            max_completion_tokens: maxCompletionTokens
          })
        });
        if (!response.ok) {
          typingElem.textContent = "Error: " + response.statusText;
          return;
        }
        const data = await response.json();
        const botReply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content 
                         ? data.choices[0].message.content.trim() 
                         : "I don't have an answer.";
        typingElem.remove();
        const botMessageElem = appendChatMessage("bot", "", "");
        typeOutText(botMessageElem, botReply, 20);
        chatMemory.push({ role: "assistant", content: botReply });
        if (chatMemory.length > 50) { chatMemory.shift(); }
      } catch (err) {
        typingElem.textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
