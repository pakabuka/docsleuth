<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DocSleuth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google Fonts for a modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Load PDF.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  <!-- Load Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <!-- Load GPT tokenizer library -->
  <script src="https://unpkg.com/gpt-tokenizer"></script>
  <!-- Load jsPDF (not used because only Word download is enabled) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Global Reset & Fonts */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #0b0c10, #1f2833);
      color: #333;
      overflow-x: hidden;
      position: relative;
      padding-bottom: 50px;
    }
    /* Starry background overlay */
    body::before {
      content: "";
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='1' fill='white'/></svg>") repeat;
      opacity: 0.3;
      animation: starryNight 100s linear infinite;
      z-index: -2;
    }
    @keyframes starryNight {
      from { background-position: 0 0; }
      to { background-position: -1000px -1000px; }
    }
    /* Spinner Styles */
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #001f3f;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-left: 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-content {
      background: #fff;
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: modalIn 0.5s ease-out;
    }
    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes modalOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .closing { animation: modalOut 0.5s ease-in forwards; }
    .modal-content input {
      width: 100%; padding: 10px; margin: 10px 0; font-size: 16px;
    }
    .disclaimer { font-size: 14px; color: #666; margin-bottom: 10px; }
    /* Header Styles (fixed height) */
    header {
      position: relative;
      text-align: center;
      padding: 20px 10px;
      background: inherit;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      overflow: hidden;
      height: 80px; /* Fixed height */
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    header h1 {
      font-size: 32px; margin: 0;
      font-family: 'Roboto', sans-serif;
      animation: zoomInOut 5s infinite;
      position: relative; z-index: 1;
    }
    @keyframes zoomInOut {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    /* Subtitle container has fixed height so header doesn't collapse */
    #header-subtitle {
      font-size: 16px;
      margin-top: 5px;
      font-style: italic;
      color: #e0e0e0;
      position: relative;
      z-index: 1;
      height: 20px; /* Reserve space */
    }
    /* Container for pages */
    .container {
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: rgba(255,255,255,0.85);
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      opacity: 0;
      animation: fadeIn 0.8s forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Drag & Drop Area */
    #drop-area {
      border: 2px dashed rgba(255,255,255,0.5);
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      background: rgba(255,255,255,0.1);
      transition: background 0.3s, border-color 0.3s;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #drop-area p { font-size: 18px; margin-bottom: 20px; color: #001f3f; }
    #drop-area:hover { background: rgba(255,255,255,0.2); }
    /* File List */
    #file-list { margin-top: 20px; }
    .file-item {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px 20px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: transform 0.2s;
      position: relative;
    }
    .file-item:hover { transform: translateY(-2px); }
    .file-item .icon { font-size: 50px; }
    .file-details { flex: 1; position: relative; }
    .file-details p { margin: 3px 0; font-size: 15px; }
    .progress-container {
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin: 10px 0;
      height: 20px;
      position: relative;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #001f3f, #555);
      text-align: center;
      color: #fff;
      line-height: 20px;
      transition: width 0.2s ease;
    }
    .remove-file {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 20px;
      color: #ff5722;
    }
    @keyframes removeAnimation {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5) rotate(45deg); }
    }
    .removing { animation: removeAnimation 0.5s forwards; }
    /* Button Container & Styles */
    .button-container { margin-top: 10px; }
    .btn {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
      margin-right: 5px;
    }
    .btn:hover { background-color: #003366; transform: scale(1.05); }
    .btn:disabled { background-color: #aaa; cursor: not-allowed; }
    /* In file controls, the Proceed button is shown only after processing,
       and the View Summary button is hidden until the AI finishes rendering */
    /* Summary Page & Dual Layout */
    #summary-page { display: none; }
    #summary-content { margin-top: 20px; }
    .summary-container {
      display: flex;
      gap: 20px;
      height: 700px;  /* Changed from 600px to 700px */
    }
    .summary-left { flex: 1; overflow-y: auto; padding-right: 10px; }
    .summary-right {
      flex: 1;
      overflow-y: auto;
      border-left: 1px solid #e0e0e0;
      padding-left: 20px;
      position: relative;
    }
    /* PDF Viewer Container with smooth scrolling and transition */
    #pdf-viewer-container {
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 10px;
      scroll-behavior: smooth;
      transition: transform 0.3s ease;
    }
    /* Download Button Placement */
    .summary-controls { margin-top: 20px; text-align: left; }
    .summary-controls button {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
    }
    .summary-controls button:hover {
      background-color: #003366;
      transform: scale(1.05);
    }
    /* Sticky Zoom Controls */
    .zoom-controls {
      position: sticky;
      top: 10px;
      z-index: 10;
      padding: 5px;
    }
    .zoom-controls button {
      background-color: #001f3f;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .zoom-controls button:hover { background-color: #003366; }
    /* Summary Sections */
    .section {
      padding: 15px;
      border: 1px solid #e0e0e0;
      margin-bottom: 15px;
      border-radius: 8px;
      background: #f9f9f9;
      transition: background 0.3s, transform 0.2s;
      cursor: pointer;
    }
    .section:hover { background: #f0f0f0; transform: translateX(5px); }
    .section.analysis {
      background: #f0fff0;
      border: 1px solid #28a745;
      color: #28a745;
      cursor: default;
    }
    .summary-left ul { padding-left: 20px; margin: 5px 0; }
    .summary-left li { margin-bottom: 5px; }
    /* Subsections styling */
    .subsections {
      margin-top: 10px;
      padding-left: 15px;
      border-left: 2px dashed #ccc;
      display: none;
    }
    .subsection { margin-bottom: 10px; }
    .subsection h4 {
      margin: 0 0 5px 0;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
    }
    /* Toggle icon for sections with subsections */
    .toggle-icon {
      margin-right: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Styled approximate page hyperlink */
    .page-link {
      color: #001f3f;
      text-decoration: underline;
      cursor: pointer;
    }
    .page-link:hover { color: #003366; }
    /* Chatbot Styles */
    .chatbot-container {
      width: 350px;
      max-height: 500px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      resize: both;
      overflow: auto;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      position: fixed;
      bottom: 70px;
      right: 20px;
    }
    .chatbot-container.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .chatbot-drag-handle {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #001f3f;
      border-radius: 3px;
      cursor: nwse-resize;
      z-index: 1010;
    }
    .chatbot-header {
      background: #001f3f;
      color: #fff;
      padding: 10px 10px 10px 30px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    .chatbot-messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #f7f7f7;
    }
    .chatbot-input-container {
      display: flex;
      border-top: 1px solid #e0e0e0;
    }
    .chatbot-input-container input {
      flex: 1;
      border: none;
      padding: 10px;
      font-size: 16px;
    }
    .chatbot-input-container button {
      border: none;
      background: #001f3f;
      color: #fff;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
    }
    /* Chatbot Toggle */
    .chatbot-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.7);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: transform 0.2s ease;
    }
    .chatbot-toggle:active { transform: scale(0.9); }
    .chatbot-message {
      margin-bottom: 5px;
      padding: 8px;
      border-radius: 5px;
      max-width: 80%;
      font-size: 16px;
    }
    .chatbot-message.user {
      background: #001f3f;
      color: #fff;
      align-self: flex-end;
    }
    .chatbot-message.bot {
      background: #eee;
      color: #333;
      align-self: flex-start;
    }
    .chatbot-message.typing { font-style: italic; color: #999; }
    /* Footer */
    footer {
      text-align: center;
      padding: 10px;
      background: inherit;
      color: #fff;
      font-size: 14px;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="token-modal" class="modal">
    <div class="modal-content">
      <h2>Enter your OpenAI API Key</h2>
      <p class="disclaimer">We DO NOT collect or store your key.</p>
      <input type="text" id="open-token-input" placeholder="Paste your OpenAI API Key here...">
      <p class="disclaimer">
        <a href="https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key" target="_blank">
          Where do I find my OpenAI API Key?
        </a>
      </p>
      <button id="open-token-submit" class="btn">Submit</button>
      <p id="token-error" style="color:red; display:none;"></p>
    </div>
  </div>

  <!-- Front Page Header with Starry Animation -->
  <header>
    <h1>DocSleuth</h1>
    <p id="header-subtitle">Uncover insights effortlessly</p>
  </header>

  <!-- Main Page -->
  <div class="container" id="main-page">
    <div id="drop-area">
      <p>Drag &amp; drop your PDF files here</p>
      <button id="fileSelect" class="btn">Select Files</button>
      <input type="file" id="fileElem" multiple accept="application/pdf" style="display:none;">
    </div>
    <div id="file-list"></div>
  </div>

  <!-- Summary Page (hidden by default) -->
  <div class="container" id="summary-page">
    <button id="back-button" class="btn">← Back to Files</button>
    <div id="summary-content"></div>
  </div>

  <!-- Footer -->
  <footer>
    <p>© 2025 Frederick Liu. All rights reserved.</p>
  </footer>

  <script>
    // Global variable for the token.
    let OPENAI_API_KEY = "";
    
    /********************************************************************
     * Token Validation and Modal Handling
     ********************************************************************/
    async function validateToken(token) {
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: { "Authorization": "Bearer " + token }
        });
        return response.ok;
      } catch (error) { return false; }
    }
    
    window.addEventListener("load", () => {
      const savedToken = sessionStorage.getItem("openToken");
      if (savedToken) { OPENAI_API_KEY = savedToken; }
      else { document.getElementById("token-modal").style.display = "flex"; }
      startTypingAnimation(); // start header subtitle animation
    });
    
    document.getElementById("open-token-submit").addEventListener("click", async function(){
      const tokenInput = document.getElementById("open-token-input");
      const token = tokenInput.value.trim();
      const errorMsg = document.getElementById("token-error");
      if (token === "") {
        errorMsg.textContent = "API Key cannot be empty.";
        errorMsg.style.display = "block";
        return;
      }
      const isValid = await validateToken(token);
      if (isValid) {
        const modalContent = document.querySelector(".modal-content");
        modalContent.classList.add("closing");
        modalContent.addEventListener("animationend", () => {
          document.getElementById("token-modal").style.display = "none";
        });
        OPENAI_API_KEY = token;
        sessionStorage.setItem("openToken", token);
      } else {
        errorMsg.textContent = "Invalid API Key. Please try again.";
        errorMsg.style.display = "block";
      }
    });
    
    /********************************************************************
     * Typing Animation for Header Subtitle
     ********************************************************************/
    function startTypingAnimation() {
      const element = document.getElementById("header-subtitle");
      const fullText = element.textContent;
      let charIndex = 0;
      let typing = true;
      function type() {
        if (typing) {
          charIndex++;
          if (charIndex > fullText.length) { typing = false; setTimeout(type, 1000); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 100); }
        } else {
          charIndex--;
          if (charIndex < 0) { typing = true; setTimeout(type, 500); }
          else { element.textContent = fullText.substring(0, charIndex); setTimeout(type, 50); }
        }
      }
      type();
    }
    
    /********************************************************************
     * Tokenizer Setup
     ********************************************************************/
    let encode;
    if (typeof GPTTokenizer_cl100k_base !== "undefined" && GPTTokenizer_cl100k_base.encode) {
      encode = GPTTokenizer_cl100k_base.encode;
    } else { encode = function(text) { return text.split(/\s+/); }; }
    
    /********************************************************************
     * Text Preprocessing Helper
     ********************************************************************/
    function preprocessText(text) {
      return text.replace(/\s+/g, ' ').trim();
    }
    
    /********************************************************************
     * Global DOM Elements and Variables
     ********************************************************************/
    const dropArea = document.getElementById('drop-area');
    const fileElem = document.getElementById('fileElem');
    const fileSelect = document.getElementById('fileSelect');
    const fileList = document.getElementById('file-list');
    const mainPage = document.getElementById('main-page');
    const summaryPage = document.getElementById('summary-page');
    const summaryContent = document.getElementById('summary-content');
    const backButton = document.getElementById('back-button');
    
    const filesData = {};
    let pdfScale = 1.2;
    let currentDocumentOriginalText = "";
    let chatMemory = [];
    
    /********************************************************************
     * File Selection and Drag & Drop Event Listeners
     ********************************************************************/
    fileSelect.addEventListener('click', () => fileElem.click());
    fileElem.addEventListener('change', handleFiles);
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => { e.preventDefault(); dropArea.classList.add('highlight'); });
    });
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => { e.preventDefault(); dropArea.classList.remove('highlight'); });
    });
    
    /********************************************************************
     * Dynamic Progress Bar Animation
     ********************************************************************/
    function updateProgress(fileId, target) {
      const progressBar = document.getElementById('progress-' + fileId);
      if (!progressBar) return;
      let current = parseInt(progressBar.textContent) || 0;
      const interval = setInterval(() => {
        if (current < target) {
          current++;
          progressBar.style.width = current + "%";
          progressBar.textContent = current + "%";
        } else { clearInterval(interval); }
      }, 20);
    }
    
    /********************************************************************
     * File Processing: Create file item with button container
     ********************************************************************/
    function handleFiles(e) {
      const files = e.target.files;
      for (let file of files) {
        if (file.type !== "application/pdf") continue;
        processFile(file);
      }
    }
    
    function processFile(file) {
      const fileId = 'file-' + Math.random().toString(36).substr(2, 9);
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      fileItem.id = fileId;
      fileItem.innerHTML = `
        <span class="remove-file" title="Remove File">🗑️</span>
        <div class="icon">📄</div>
        <div class="file-details">
          <p><strong>${file.name}</strong></p>
          <p>${(file.size / 1024).toFixed(2)} KB</p>
          <div class="progress-container">
            <div class="progress-bar" id="progress-${fileId}">0%</div>
          </div>
          <div class="token-info" id="token-info-${fileId}" style="position: absolute; bottom: 5px; right: 10px; font-size: 12px; color: #555;">
            Tokens: 0 | Cost: $0.00
          </div>
          <div class="button-container">
            <button id="submit-btn-${fileId}" class="btn">Submit</button>
            <button id="proceed-btn-${fileId}" class="btn" style="display:none;">Proceed</button>
            <button id="summary-btn-${fileId}" class="btn" style="display:none;">View Summary</button>
          </div>
        </div>
      `;
      fileList.appendChild(fileItem);
      
      const removeIcon = fileItem.querySelector('.remove-file');
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        fileItem.classList.add("removing");
        fileItem.addEventListener("animationend", () => {
          if(fileList.contains(fileItem)) { fileList.removeChild(fileItem); }
          delete filesData[fileId];
        });
      });
      
      const submitBtn = document.getElementById(`submit-btn-${fileId}`);
      submitBtn.addEventListener('click', () => {
        submitBtn.disabled = true;
        submitBtn.style.backgroundColor = "#aaa";
        summarizePDF(file, fileId);
      });
    }
    
    /********************************************************************
     * PDF Extraction & OCR Functions
     ********************************************************************/
    async function extractPDFText(file) {
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const hasTwoColumns = await detectTwoColumns(canvas, context);
        let pageText = "";
        if (hasTwoColumns) {
          const leftCanvas = document.createElement("canvas");
          leftCanvas.width = Math.floor(canvas.width / 2);
          leftCanvas.height = canvas.height;
          const leftCtx = leftCanvas.getContext("2d");
          leftCtx.drawImage(canvas, 0, 0, leftCanvas.width, leftCanvas.height);
          const rightCanvas = document.createElement("canvas");
          rightCanvas.width = Math.ceil(canvas.width / 2);
          rightCanvas.height = canvas.height;
          const rightCtx = rightCanvas.getContext("2d");
          rightCtx.drawImage(canvas, leftCanvas.width, 0, rightCanvas.width, rightCanvas.height);
          const leftText = await performOCR(leftCanvas);
          const rightText = await performOCR(rightCanvas);
          pageText = leftText + "\n" + rightText;
        } else {
          pageText = await performOCR(canvas);
        }
        fullText += pageText + "\n";
      }
      return fullText;
    }
    
    async function detectTwoColumns(canvas, context) {
      const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const textPixelThreshold = 200;
      const nonWhitePixelCount = (xStart, xEnd) => {
        let count = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = xStart; x < xEnd; x++) {
            const index = (y * canvas.width + x) * 4;
            const brightness = (data[index] + data[index+1] + data[index+2]) / 3;
            if (brightness < textPixelThreshold) count++;
          }
        }
        return count;
      };
      const midX = Math.floor(canvas.width / 2);
      const leftCount = nonWhitePixelCount(0, midX);
      const rightCount = nonWhitePixelCount(midX, canvas.width);
      const ratio = leftCount / rightCount;
      const minCount = 10000, maxRatio = 1.5;
      return (leftCount > minCount && rightCount > minCount && ratio > (1/maxRatio) && ratio < maxRatio);
    }
    
    async function performOCR(canvas) {
      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng', { logger: m => m });
        return text;
      } catch (error) {
        console.error("OCR Error:", error);
        return "";
      }
    }
    
    /********************************************************************
     * Summarization & JSON Parsing
     * 
     * The prompt now instructs the AI to structure the summary based on
     * the original document's headers/sub-headers, if present.
     * The Proceed button is shown after extraction; the View Summary
     * button appears only when the API call finishes.
     ********************************************************************/
    async function summarizePDF(file, fileId) {
      const progressBar = document.getElementById('progress-' + fileId);
      const summaryBtn = document.getElementById('summary-btn-' + fileId);
      const fileItem = document.getElementById(fileId);
      const buttonContainer = fileItem.querySelector('.button-container');
      
      // Show spinner immediately when Submit is clicked.
      let initialSpinner = document.createElement("div");
      initialSpinner.className = "spinner";
      buttonContainer.appendChild(initialSpinner);
      
      try {
        updateProgress(fileId, 20);
        const pdfText = await extractPDFText(file);
        updateProgress(fileId, 40);
        
        const cleanedText = preprocessText(pdfText);
        const tokenCount = encode(cleanedText).length;
        if (tokenCount > 200000) {
          const errorMsg = document.createElement("p");
          errorMsg.style.color = "red";
          errorMsg.textContent = "Unable to process file due to large token count.";
          fileItem.appendChild(errorMsg);
          initialSpinner.remove();
          return;
        }
        
        const tokenCost = ((tokenCount / 1000000) * 1.10).toFixed(2);
        document.getElementById(`token-info-${fileId}`).innerText = `Tokens: ${tokenCount} | Cost: $${tokenCost}`;
        
        filesData[fileId] = { file: file, originalText: cleanedText };
        
        // Remove spinner when extraction is complete.
        initialSpinner.remove();
    
        // Show the Proceed button and keep the View Summary button hidden.
        let proceedBtn = document.getElementById(`proceed-btn-${fileId}`);
        summaryBtn.style.display = "none";
        proceedBtn.style.display = "inline-block";
        proceedBtn.disabled = false;
    
        // Wait for the user to click the "Proceed" button.
        proceedBtn.addEventListener("click", async function onProceed() {
          proceedBtn.removeEventListener("click", onProceed);
          proceedBtn.disabled = true;
          let proceedSpinner = document.createElement("div");
          proceedSpinner.className = "spinner";
          buttonContainer.appendChild(proceedSpinner);
    
          // Enhanced prompt: instruct the AI to use original headers if available.
          const prompt = `Generate an extremely, super detailed, structured summary of the following PDF content. Divide the summary into multiple sections; if a section is large, subdivide it into subsections. If the original document contains clearly labeled section headers or sub-headers (for example, "Introduction", "Literature Review", etc.), organize the summary according to those headers. For each section or subsection, include a header, well-formatted content (using bullet points, paragraphs, etc.), and a "page" field indicating the approximate page number from the original PDF where that content appears (except for the Analysis section). Output the summary as valid JSON strictly following this format (and nothing else):

{
  "title": "Summary of ${file.name}",
  "sections": [
    { "header": "Section Header", "content": "Section Content", "page": 1 },
    { "header": "Section Header with Subsections", "content": "Main content summary", "subsections": [
         { "header": "Subsection Header", "content": "Subsection Content", "page": 3 },
         ... additional subsections ...
       ]
    },
    { "header": "Analysis", "content": "Your two paragraph analysis here." }
  ]
}

Replace the placeholder texts with appropriate values based on the PDF content.

PDF Content:
${cleanedText}`;
    
          updateProgress(fileId, 60);
    
          const totalTokenLimit = 200000;
          const promptTokens = encode(prompt).length;
          const bufferTokens = 100;
          const computedCompletionTokens = totalTokenLimit - promptTokens - bufferTokens;
          const maxCompletionTokens = computedCompletionTokens > 1000 ? Math.min(computedCompletionTokens, 100000) : 1000;
    
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${OPENAI_API_KEY}`
            },
            body: JSON.stringify({
              model: "o3-mini",
              messages: [{ role: "user", content: prompt }],
              max_completion_tokens: maxCompletionTokens
            })
          });
    
          updateProgress(fileId, 80);
          if (!response.ok) {
            proceedSpinner.remove();
            const errorMsg = document.createElement("p");
            errorMsg.style.color = "red";
            errorMsg.textContent = "OpenAI API error: " + response.statusText;
            fileItem.appendChild(errorMsg);
            return;
          }
          const data = await response.json();
          const summaryOutput = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
            ? data.choices[0].message.content.trim() : null;
          let structuredSummary;
          try {
            structuredSummary = JSON.parse(summaryOutput);
          } catch (e) {
            structuredSummary = {
              title: `Summary of ${file.name}`,
              sections: [
                { header: "Summary", content: summaryOutput || "No summary was generated.", page: 1 }
              ]
            };
          }
          updateProgress(fileId, 100);
          filesData[fileId].summary = structuredSummary;
    
          proceedSpinner.remove();
          // Now, show the View Summary button after the AI summarization is finished.
          summaryBtn.style.display = "inline-block";
          summaryBtn.disabled = false;
          summaryBtn.addEventListener('click', () => showSummaryPage(fileId));
        });
      } catch (error) {
        console.error("Error processing PDF:", error);
        progressBar.style.background = "red";
        summaryBtn.textContent = "Error Summarizing";
      }
    }
    
    /********************************************************************
     * PDF Rendering & Smooth Zoom Controls
     ********************************************************************/
    async function renderPDFPages(file, container, scale) {
      container.innerHTML = "";
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: scale });
        const canvas = document.createElement("canvas");
        canvas.id = "pdf-page-" + i;
        canvas.style.marginBottom = "10px";
        // Add smooth transform transition
        canvas.style.transition = "transform 0.3s ease";
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext("2d");
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        container.appendChild(canvas);
      }
    }
    
    function navigateToPage(page) {
      const target = document.getElementById('pdf-page-' + page);
      if (target) target.scrollIntoView({ behavior: "smooth" });
      else alert("Page " + page + " not found.");
    }
    
    /********************************************************************
     * Content Formatting Helpers
     ********************************************************************/
    function formatContent(text) {
      const lines = text.split('\n');
      let html = '';
      let listOpen = false;
      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('- ') || line.startsWith('• ')) {
          if (!listOpen) { html += '<ul>'; listOpen = true; }
          let item = line.substring(2).trim();
          html += `<li>${item}</li>`;
        } else {
          if (listOpen) { html += '</ul>'; listOpen = false; }
          if (line) { html += `<p>${line}</p>`; }
        }
      });
      if (listOpen) { html += '</ul>'; }
      return html;
    }
    
    // Generates HTML for the detailed summary view.
    function generateDetailedSummaryHTML(summary) {
      let html = `<h2>${summary.title}</h2>`;
      summary.sections.forEach((section, index) => {
        let toggle = "";
        if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
          toggle = `<span class="toggle-icon">▼</span>`;
        }
        html += `<div class="section" data-index="${index}">
          <h3>${toggle}${section.header}</h3>
          <div class="section-content">${formatContent(section.content)}</div>`;
        // For non-Analysis sections without subsections, show approximate page link.
        if (section.header.toLowerCase() !== "analysis" && section.page && (!section.subsections || section.subsections.length === 0)) {
          html += `<p><em>Approximate page: <a class="page-link" href="#" onclick="navigateToPage(${section.page}); return false;">${section.page}</a></em></p>`;
        }
        if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
          html += `<div class="subsections">`;
          section.subsections.forEach(subsection => {
            html += `<div class="subsection">
              <h4>${subsection.header}</h4>
              <div class="subsection-content">${formatContent(subsection.content)}</div>`;
            if (subsection.page) {
              html += `<p><em>Approximate page: <a class="page-link" href="#" onclick="navigateToPage(${subsection.page}); return false;">${subsection.page}</a></em></p>`;
            }
            html += `</div>`;
          });
          html += `</div>`;
        }
        html += `</div>`;
      });
      return html;
    }
    
    // Generates a nicely formatted HTML document for Word output.
    function generateWordDocumentHTML(summary) {
      let html = `
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${summary.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          h1, h2, h3, h4 { color: #001f3f; }
          h1 { font-size: 28px; text-align: center; margin-bottom: 20px; }
          h2 { font-size: 24px; margin-top: 20px; }
          h3 { font-size: 20px; margin-top: 15px; }
          h4 { font-size: 18px; margin-top: 10px; }
          p { font-size: 14px; line-height: 1.6; margin: 8px 0; }
          ul { margin: 10px 0 10px 20px; }
          .section { margin-bottom: 20px; }
          .subsections { margin-left: 20px; border-left: 2px solid #ccc; padding-left: 10px; }
          .analysis { background: #f0fff0; border: 1px solid #28a745; padding: 10px; }
        </style>
      </head>
      <body>
        <h1>${summary.title}</h1>
      `;
      summary.sections.forEach(section => {
        if (section.header.toLowerCase() === "analysis") {
          html += `<div class="section analysis">
                    <h2>${section.header}</h2>
                    ${formatContent(section.content)}
                  </div>`;
        } else {
          html += `<div class="section">
                    <h2>${section.header}</h2>
                    ${formatContent(section.content)}
                  `;
          if (section.subsections && Array.isArray(section.subsections) && section.subsections.length > 0) {
            html += `<div class="subsections">`;
            section.subsections.forEach(subsec => {
              html += `<div class="subsection">
                        <h3>${subsec.header}</h3>
                        ${formatContent(subsec.content)}
                      </div>`;
            });
            html += `</div>`;
          } else if (section.page) {
            html += `<p><em>Approximate page: ${section.page}</em></p>`;
          }
          html += `</div>`;
        }
      });
      html += `</body></html>`;
      return html;
    }
    
    function downloadFormattedSummary(summary, format) {
  let htmlContent = "";
  if (format === "word") { 
    htmlContent = generateWordDocumentHTML(summary); 
  } else { 
    htmlContent = generateDetailedSummaryHTML(summary); 
  }
  const blob = new Blob(['\ufeff', htmlContent], { type: 'application/msword' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  // Use the summary title (which includes the PDF's file name) for the download name.
  a.download = summary.title.replace(/\s+/g, '_') + ".doc";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
    /********************************************************************
     * Display Summary and PDF Viewer with Zoom Controls & Chatbot
     ********************************************************************/
    async function showSummaryPage(fileId) {
      const data = filesData[fileId];
      if (!data) return;
      document.querySelector("header").style.display = "none";
      currentDocumentOriginalText = data.originalText;
      
      mainPage.style.display = 'none';
      summaryPage.style.display = 'block';
      
      let summaryLeftHTML = generateDetailedSummaryHTML(data.summary);
      summaryLeftHTML += `
        <div class="summary-controls">
          <button id="download-word" class="btn">Download as Word</button>
        </div>`;
      
      summaryContent.innerHTML = `
        <div class="summary-container">
          <div class="summary-left">${summaryLeftHTML}</div>
          <div class="summary-right">
            <div class="zoom-controls">
              <button id="zoom-in">Zoom In</button>
              <button id="zoom-out">Zoom Out</button>
            </div>
            <div id="pdf-viewer-container"></div>
          </div>
        </div>`;
      
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');
      renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      
      // Toggle behavior for sections with subsections.
      document.querySelectorAll('.section').forEach(sectionElem => {
        const subsectionsDiv = sectionElem.querySelector('.subsections');
        if (subsectionsDiv) {
          const header = sectionElem.querySelector('h3, h2');
          header.style.cursor = "pointer";
          header.addEventListener('click', () => {
            subsectionsDiv.style.display = (subsectionsDiv.style.display === "none" ? "block" : "none");
          });
        }
      });
      
      document.getElementById('zoom-in').addEventListener('click', () => {
        pdfScale += 0.2;
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      document.getElementById('zoom-out').addEventListener('click', () => {
        if (pdfScale > 0.4) { pdfScale -= 0.2; }
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      
      pdfViewerContainer.addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
          e.preventDefault();
          pdfScale += (e.deltaY < 0 ? 0.1 : -0.1);
          pdfScale = Math.max(0.1, pdfScale);
          renderPDFPages(data.file, pdfViewerContainer, pdfScale);
        }
      });
      
      setupDownloadButtons(data.summary);
      createChatbot();
      chatMemory = [];
    }
    
    function setupDownloadButtons(summary) {
      document.getElementById('download-word').onclick = () => { downloadFormattedSummary(summary, "word"); };
    }
    
    backButton.addEventListener('click', () => {
      summaryPage.style.display = 'none';
      mainPage.style.display = 'block';
      document.querySelector("header").style.display = "block";
      const chatbotToggle = document.getElementById('chatbot-toggle');
      const chatbotContainer = document.getElementById('chatbot-container');
      if (chatbotToggle) chatbotToggle.style.display = 'none';
      if (chatbotContainer) chatbotContainer.classList.remove("visible");
    });
    
    /********************************************************************
     * Chatbot Implementation with Memory and Document Context
     ********************************************************************/
    function createChatbot() {
      let chatbotToggle = document.getElementById('chatbot-toggle');
      let chatbotContainer = document.getElementById('chatbot-container');
      if (!chatbotToggle) {
        chatbotToggle = document.createElement('div');
        chatbotToggle.id = "chatbot-toggle";
        chatbotToggle.className = "chatbot-toggle";
        chatbotToggle.innerHTML = "💬";
        document.body.appendChild(chatbotToggle);
      }
      if (!chatbotContainer) {
        chatbotContainer = document.createElement('div');
        chatbotContainer.id = "chatbot-container";
        chatbotContainer.className = "chatbot-container";
        chatbotContainer.innerHTML = `
          <div id="chatbot-drag-handle" class="chatbot-drag-handle"></div>
          <div id="chatbot-header" class="chatbot-header">Document Chat</div>
          <div id="chatbot-messages" class="chatbot-messages"></div>
          <div class="chatbot-input-container">
            <input type="text" id="chatbot-input" placeholder="Type your message...">
            <button id="chatbot-send" class="btn">Send</button>
          </div>
        `;
        document.body.appendChild(chatbotContainer);
        makeChatbotResizable();
      }
      chatbotContainer.classList.remove("visible");
      chatbotToggle.style.display = "flex";
      
      if (!chatbotToggle.dataset.listenerAdded) {
        chatbotToggle.addEventListener('click', () => {
          if (chatbotContainer.classList.contains("visible")) { chatbotContainer.classList.remove("visible"); }
          else { chatbotContainer.classList.add("visible"); }
        });
        chatbotToggle.dataset.listenerAdded = "true";
      }
      
      const sendButton = document.getElementById('chatbot-send');
      const inputField = document.getElementById('chatbot-input');
      if (!sendButton.dataset.listenerAdded) {
        sendButton.addEventListener('click', sendChatMessage);
        sendButton.dataset.listenerAdded = "true";
      }
      if (!inputField.dataset.listenerAdded) {
        inputField.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') sendChatMessage();
        });
        inputField.dataset.listenerAdded = "true";
      }
    }
    
    function makeChatbotResizable() {
      const handle = document.getElementById('chatbot-drag-handle');
      const container = document.getElementById('chatbot-container');
      handle.addEventListener('mousedown', initDrag);
      function initDrag(e) {
        e.preventDefault();
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
      }
      function doDrag(e) {
        const rect = container.getBoundingClientRect();
        const newWidth = rect.right - e.clientX;
        const newHeight = rect.bottom - e.clientY;
        if(newWidth > 200) { container.style.width = newWidth + 'px'; }
        if(newHeight > 150) { container.style.height = newHeight + 'px'; }
      }
      function stopDrag(e) {
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
      }
    }
    
    function appendChatMessage(sender, text, extraClass="") {
      const messagesContainer = document.getElementById('chatbot-messages');
      const messageElem = document.createElement('div');
      messageElem.classList.add('chatbot-message', sender);
      if (extraClass) messageElem.classList.add(extraClass);
      messageElem.textContent = text;
      messagesContainer.appendChild(messageElem);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return messageElem;
    }
    
    function typeOutText(element, text, interval) {
      let index = 0;
      const timer = setInterval(() => {
        if (index < text.length) { element.textContent += text.charAt(index); index++; }
        else { clearInterval(timer); }
      }, interval);
    }
    
    async function sendChatMessage() {
      const inputElem = document.getElementById('chatbot-input');
      const message = inputElem.value.trim();
      if (!message) return;
      appendChatMessage("user", message);
      inputElem.value = "";
      
      chatMemory.push({ role: "user", content: message });
      if (chatMemory.length > 50) { chatMemory.shift(); }
      
      let contextText = currentDocumentOriginalText;
      
      const conversation = [
        { role: "system", content: "You are an AI assistant that only responds based on the following document (do not include any external information):\n" + contextText }
      ].concat(chatMemory);
      
      const totalTokenLimit = 200000;
      let conversationContent = conversation.map(msg => msg.content).join(" ");
      const conversationTokens = encode(conversationContent).length;
      const bufferTokens = 100;
      const computed = totalTokenLimit - conversationTokens - bufferTokens;
      const maxCompletionTokens = computed > 1000 ? Math.min(computed, 100000) : 1000;
      
      const typingElem = appendChatMessage("bot", "AI is typing...", "typing");
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
             "Content-Type": "application/json",
             "Authorization": `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: "o3-mini",
            messages: conversation,
            max_completion_tokens: maxCompletionTokens
          })
        });
        if (!response.ok) {
          typingElem.textContent = "Error: " + response.statusText;
          return;
        }
        const data = await response.json();
        const botReply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content 
                         ? data.choices[0].message.content.trim() 
                         : "I don't have an answer.";
        typingElem.remove();
        const botMessageElem = appendChatMessage("bot", "", "");
        typeOutText(botMessageElem, botReply, 20);
        chatMemory.push({ role: "assistant", content: botReply });
        if (chatMemory.length > 50) { chatMemory.shift(); }
      } catch (err) {
        typingElem.textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
