<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DocSleuth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Load PDF.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  <!-- Load Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <!-- Load GPT tokenizer library -->
  <script src="https://unpkg.com/gpt-tokenizer"></script>
  <!-- Load jsPDF (not used because only Word download is enabled) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    /* Global Reset & Fonts */
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      /* Dark gradient background for a starry night effect */
      background: linear-gradient(135deg, #0b0c10, #1f2833);
      color: #333;
      overflow-x: hidden;
      position: relative;
      padding-bottom: 50px; /* space for footer */
    }
    /* Starry night overlay for the entire page */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* A small SVG star pattern repeated */
      background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='1' fill='white'/></svg>") repeat;
      opacity: 0.3;
      animation: starryNight 100s linear infinite;
      z-index: -2;
    }
    @keyframes starryNight {
      from { background-position: 0 0; }
      to { background-position: -1000px -1000px; }
    }
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-content {
      background: #fff;
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      animation: modalIn 0.5s ease-out;
    }
    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
    @keyframes modalOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.8); }
    }
    .closing {
      animation: modalOut 0.5s ease-in forwards;
    }
    .modal-content input {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      font-size: 16px;
    }
    .disclaimer {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }
    /* Front Page Header – Inherit background from body so it matches the general background */
    header {
      position: relative;
      text-align: center;
      padding: 20px 10px;
      background: inherit;
      color: #fff;
      /* Remove individual header background so it exactly matches the page */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    header h1 {
      font-size: 32px;
      margin: 0;
      font-family: 'Georgia', serif;
      position: relative;
      z-index: 1;
    }
    header p {
      font-size: 16px;
      margin-top: 5px;
      font-style: italic;
      color: #e0e0e0;
      position: relative;
      z-index: 1;
    }
    /* Container for pages */
    .container {
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      opacity: 0;
      animation: fadeIn 0.8s forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Drag & Drop Area: Transparent and stylish */
    #drop-area {
      border: 2px dashed rgba(204,204,204,0.5);
      border-radius: 10px;
      padding: 40px;
      text-align: center;
      background: rgba(250,250,250,0.3);
      transition: background 0.3s, border-color 0.3s;
      cursor: pointer;
      margin-bottom: 20px;
    }
    #drop-area:hover {
      background: rgba(240,240,240,0.4);
    }
    #drop-area p { font-size: 18px; margin-bottom: 20px; color: #555; }
    /* File List */
    #file-list { margin-top: 20px; }
    .file-item {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px 20px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: transform 0.2s;
      position: relative;
    }
    .file-item:hover { transform: translateY(-2px); }
    .file-item .icon { font-size: 50px; }
    .file-details { flex: 1; }
    .file-details p { margin: 3px 0; font-size: 15px; }
    .progress-container {
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin: 10px 0;
      height: 20px;
      position: relative;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #001f3f, #555);
      text-align: center;
      color: #fff;
      line-height: 20px;
      transition: width 0.2s ease;
    }
    .remove-file {
      position: absolute;
      top: 5px;
      right: 5px;
      cursor: pointer;
      font-size: 20px;
      color: #ff5722;
    }
    @keyframes removeAnimation {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.5) rotate(45deg); }
    }
    .removing {
      animation: removeAnimation 0.5s forwards;
    }
    /* Button Styles */
    .btn {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
    }
    .btn:hover {
      background-color: #003366;
      transform: scale(1.05);
    }
    .btn:disabled {
      background-color: #aaa;
      cursor: not-allowed;
    }
    /* Summary Page & Dual Layout */
    #summary-page { display: none; }
    #summary-content { margin-top: 20px; }
    .summary-container {
      display: flex;
      gap: 20px;
      height: 800px;
    }
    .summary-left {
      flex: 1;
      overflow-y: auto;
      padding-right: 10px;
    }
    .summary-right {
      flex: 1;
      overflow-y: auto;
      border-left: 1px solid #e0e0e0;
      padding-left: 20px;
      position: relative;
    }
    /* Download Button Placement */
    .summary-controls {
      margin-top: 20px;
      text-align: left;
    }
    .summary-controls button {
      background-color: #001f3f;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s ease, transform 0.2s ease;
      cursor: pointer;
    }
    .summary-controls button:hover {
      background-color: #003366;
      transform: scale(1.05);
    }
    /* Sticky Zoom Controls */
    .zoom-controls {
      position: sticky;
      top: 10px;
      z-index: 10;
      padding: 5px;
    }
    .zoom-controls button {
      background-color: #001f3f;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 5px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .zoom-controls button:hover {
      background-color: #003366;
    }
    /* Summary Sections */
    .section {
      padding: 15px;
      border: 1px solid #e0e0e0;
      margin-bottom: 15px;
      border-radius: 8px;
      background: #f9f9f9;
      transition: background 0.3s, transform 0.2s;
      cursor: pointer;
    }
    .section:hover {
      background: #f0f0f0;
      transform: translateX(5px);
    }
    .section.analysis {
      background: #f0fff0;
      border: 1px solid #28a745;
      color: #28a745;
      cursor: default;
    }
    .summary-left ul {
      padding-left: 20px;
      margin: 5px 0;
    }
    .summary-left li { margin-bottom: 5px; }
    /* Chatbot Styles */
    .chatbot-container {
      width: 350px;
      max-height: 500px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      resize: both;
      overflow: auto;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      position: fixed;
      bottom: 70px;
      right: 20px;
    }
    .chatbot-container.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .chatbot-drag-handle {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #001f3f;
      border-radius: 3px;
      cursor: nwse-resize;
      z-index: 1010;
    }
    .chatbot-header {
      background: #001f3f;
      color: #fff;
      padding: 10px;
      padding-left: 30px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    .chatbot-messages {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: #f7f7f7;
    }
    .chatbot-input-container {
      display: flex;
      border-top: 1px solid #e0e0e0;
    }
    .chatbot-input-container input {
      flex: 1;
      border: none;
      padding: 10px;
      font-size: 16px;
    }
    .chatbot-input-container button {
      border: none;
      background: #001f3f;
      color: #fff;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
    }
    /* Chatbot Toggle: Semi-transparent gray circle */
    .chatbot-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(128,128,128,0.7);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: transform 0.2s ease;
    }
    .chatbot-toggle:active {
      transform: scale(0.9);
    }
    .chatbot-message {
      margin-bottom: 5px;
      padding: 8px;
      border-radius: 5px;
      max-width: 80%;
      font-size: 16px;
    }
    .chatbot-message.user {
      background: #001f3f;
      color: #fff;
      align-self: flex-end;
    }
    .chatbot-message.bot {
      background: #eee;
      color: #333;
      align-self: flex-start;
    }
    .chatbot-message.typing {
      font-style: italic;
      color: #999;
    }
    /* Footer Styles: Inherit the general background */
    footer {
      text-align: center;
      padding: 10px;
      background: inherit;
      color: #fff;
      font-size: 14px;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="token-modal" class="modal">
    <div class="modal-content">
      <h2>Enter your OpenAI API Key</h2>
      <p class="disclaimer">We DO NOT collect or store your key.</p>
      <input type="text" id="open-token-input" placeholder="Paste your OpenAI API Key here...">
      <p class="disclaimer">
        <a href="https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key" target="_blank">
          Where do I find my OpenAI API Key?
        </a>
      </p>
      <button id="open-token-submit" class="btn">Submit</button>
      <p id="token-error" style="color:red; display:none;"></p>
    </div>
  </div>

  <!-- Front Page Header with Starry Animation -->
  <header>
    <h1>DocSleuth</h1>
    <p>Uncover insights effortlessly</p>
  </header>

  <!-- Main Page -->
  <div class="container" id="main-page">
    <div id="drop-area">
      <p>Drag &amp; drop your PDF files here</p>
      <button id="fileSelect" class="btn">Select Files</button>
      <input type="file" id="fileElem" multiple accept="application/pdf" style="display:none;">
    </div>
    <div id="file-list"></div>
  </div>

  <!-- Summary Page (hidden by default) -->
  <div class="container" id="summary-page">
    <button id="back-button" class="btn">← Back to Files</button>
    <div id="summary-content"></div>
  </div>

  <!-- Footer -->
  <footer>
    <p>© 2025 Frederick Liu. All rights reserved.</p>
  </footer>

  <script>
    // Global variable for the token.
    let OPENAI_API_KEY = "";
    
    /********************************************************************
     * Token Validation and Modal Handling
     ********************************************************************/
    async function validateToken(token) {
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          headers: { "Authorization": "Bearer " + token }
        });
        return response.ok;
      } catch (error) {
        return false;
      }
    }
    
    window.addEventListener("load", () => {
      const savedToken = sessionStorage.getItem("openToken");
      if (savedToken) {
        OPENAI_API_KEY = savedToken;
      } else {
        document.getElementById("token-modal").style.display = "flex";
      }
    });
    
    document.getElementById("open-token-submit").addEventListener("click", async function(){
      const tokenInput = document.getElementById("open-token-input");
      const token = tokenInput.value.trim();
      const errorMsg = document.getElementById("token-error");
      if (token === "") {
        errorMsg.textContent = "API Key cannot be empty.";
        errorMsg.style.display = "block";
        return;
      }
      const isValid = await validateToken(token);
      if (isValid) {
        const modalContent = document.querySelector(".modal-content");
        modalContent.classList.add("closing");
        modalContent.addEventListener("animationend", () => {
          document.getElementById("token-modal").style.display = "none";
        });
        OPENAI_API_KEY = token;
        sessionStorage.setItem("openToken", token);
      } else {
        errorMsg.textContent = "Invalid API Key. Please try again.";
        errorMsg.style.display = "block";
      }
    });
    
    /********************************************************************
     * Tokenizer Setup
     ********************************************************************/
    let encode;
    if (typeof GPTTokenizer_cl100k_base !== "undefined" && GPTTokenizer_cl100k_base.encode) {
      encode = GPTTokenizer_cl100k_base.encode;
    } else {
      encode = function(text) { return text.split(/\s+/); };
    }
    
    /********************************************************************
     * Global DOM Elements and Variables
     ********************************************************************/
    const dropArea = document.getElementById('drop-area');
    const fileElem = document.getElementById('fileElem');
    const fileSelect = document.getElementById('fileSelect');
    const fileList = document.getElementById('file-list');
    const mainPage = document.getElementById('main-page');
    const summaryPage = document.getElementById('summary-page');
    const summaryContent = document.getElementById('summary-content');
    const backButton = document.getElementById('back-button');
    
    const filesData = {};
    let pdfScale = 1.2;
    let currentDocumentOriginalText = "";
    let chatMemory = [];
    
    /********************************************************************
     * File Selection and Drag & Drop Event Listeners
     ********************************************************************/
    fileSelect.addEventListener('click', () => fileElem.click());
    fileElem.addEventListener('change', handleFiles);
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => { e.preventDefault(); dropArea.classList.add('highlight'); });
    });
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => { e.preventDefault(); dropArea.classList.remove('highlight'); });
    });
    
    /********************************************************************
     * Dynamic Progress Bar Animation
     ********************************************************************/
    function updateProgress(fileId, target) {
      const progressBar = document.getElementById('progress-' + fileId);
      if (!progressBar) return;
      let current = parseInt(progressBar.textContent) || 0;
      const interval = setInterval(() => {
        if (current < target) {
          current++;
          progressBar.style.width = current + "%";
          progressBar.textContent = current + "%";
        } else {
          clearInterval(interval);
        }
      }, 20);
    }
    
    /********************************************************************
     * File Processing: Create file item with removal icon and buttons
     ********************************************************************/
    function handleFiles(e) {
      const files = e.target.files;
      for (let file of files) {
        if (file.type !== "application/pdf") continue;
        processFile(file);
      }
    }
    
    function processFile(file) {
      const fileId = 'file-' + Math.random().toString(36).substr(2, 9);
      const fileItem = document.createElement('div');
      fileItem.className = 'file-item';
      fileItem.id = fileId;
      fileItem.innerHTML = `
        <span class="remove-file" title="Remove File">🗑️</span>
        <div class="icon">📄</div>
        <div class="file-details">
          <p><strong>${file.name}</strong></p>
          <p>${(file.size / 1024).toFixed(2)} KB</p>
          <div class="progress-container">
            <div class="progress-bar" id="progress-${fileId}">0%</div>
          </div>
          <button id="submit-btn-${fileId}" class="btn">Submit</button>
          <button id="summary-btn-${fileId}" class="btn" disabled style="display: none;">View Summary</button>
        </div>
      `;
      fileList.appendChild(fileItem);
      
      const removeIcon = fileItem.querySelector('.remove-file');
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        fileItem.classList.add("removing");
        fileItem.addEventListener("animationend", () => {
          if(fileList.contains(fileItem)) {
            fileList.removeChild(fileItem);
          }
          delete filesData[fileId];
        });
      });
      
      const submitBtn = document.getElementById(`submit-btn-${fileId}`);
      submitBtn.addEventListener('click', () => {
        submitBtn.disabled = true;
        submitBtn.style.backgroundColor = "#aaa";
        summarizePDF(file, fileId);
      });
    }
    
    /********************************************************************
     * PDF Extraction & OCR Functions
     ********************************************************************/
    async function extractPDFText(file) {
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const hasTwoColumns = await detectTwoColumns(canvas, context);
        let pageText = "";
        if (hasTwoColumns) {
          const leftCanvas = document.createElement("canvas");
          leftCanvas.width = Math.floor(canvas.width / 2);
          leftCanvas.height = canvas.height;
          const leftCtx = leftCanvas.getContext("2d");
          leftCtx.drawImage(canvas, 0, 0, leftCanvas.width, leftCanvas.height);
          const rightCanvas = document.createElement("canvas");
          rightCanvas.width = Math.ceil(canvas.width / 2);
          rightCanvas.height = canvas.height;
          const rightCtx = rightCanvas.getContext("2d");
          rightCtx.drawImage(canvas, leftCanvas.width, 0, rightCanvas.width, rightCanvas.height);
          const leftText = await performOCR(leftCanvas);
          const rightText = await performOCR(rightCanvas);
          pageText = leftText + "\n" + rightText;
        } else {
          pageText = await performOCR(canvas);
        }
        fullText += pageText + "\n";
      }
      return fullText;
    }
    
    async function detectTwoColumns(canvas, context) {
      const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const textPixelThreshold = 200;
      const nonWhitePixelCount = (xStart, xEnd) => {
        let count = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = xStart; x < xEnd; x++) {
            const index = (y * canvas.width + x) * 4;
            const brightness = (data[index] + data[index+1] + data[index+2]) / 3;
            if (brightness < textPixelThreshold) count++;
          }
        }
        return count;
      };
      const midX = Math.floor(canvas.width / 2);
      const leftCount = nonWhitePixelCount(0, midX);
      const rightCount = nonWhitePixelCount(midX, canvas.width);
      const ratio = leftCount / rightCount;
      const minCount = 10000, maxRatio = 1.5;
      return (leftCount > minCount && rightCount > minCount && ratio > (1/maxRatio) && ratio < maxRatio);
    }
    
    async function performOCR(canvas) {
      try {
        const { data: { text } } = await Tesseract.recognize(canvas, 'eng', { logger: m => m });
        return text;
      } catch (error) {
        console.error("OCR Error:", error);
        return "";
      }
    }
    
    /********************************************************************
     * Summarization & JSON Parsing
     ********************************************************************/
    async function summarizePDF(file, fileId) {
      const progressBar = document.getElementById('progress-' + fileId);
      const summaryButton = document.getElementById('summary-btn-' + fileId);
      try {
        updateProgress(fileId, 20);
        const pdfText = await extractPDFText(file);
        updateProgress(fileId, 40);
    
        filesData[fileId] = { file: file, originalText: pdfText };
    
        const prompt = `Generate a detailed, structured summary of the following PDF content. Divide the summary into multiple sections, each with a clear header, well-formatted content (using bullet points, paragraphs, etc.), and include a "page" field indicating the approximate page number where that content originates. Additionally, include an extra section with header "Analysis" that contains two paragraphs analyzing the content of the PDF file and offering your own opinion on it (this section does not require a "page" field). Output the summary as valid JSON strictly following this format (and nothing else):

{
  "title": "Summary of ${file.name}",
  "sections": [
    { "header": "Section Header", "content": "Section Content", "page": 1 },
    ... additional sections ...,
    { "header": "Analysis", "content": "Your two paragraph analysis here." }
  ]
}

Replace "Section Header", "Section Content", and the page numbers with appropriate values based on the PDF content.

PDF Content:
${pdfText}`;
    
        const totalTokenLimit = 20000;
        const promptTokens = encode(prompt).length;
        const bufferTokens = 100;
        const maxCompletionTokens = Math.max(totalTokenLimit - promptTokens - bufferTokens, 0);
    
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: "o3-mini",
            messages: [{ role: "user", content: prompt }],
            max_completion_tokens: maxCompletionTokens
          })
        });
    
        updateProgress(fileId, 70);
        if (!response.ok) throw new Error("OpenAI API error: " + response.statusText);
        const data = await response.json();
        const summaryOutput = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
          ? data.choices[0].message.content.trim() : null;
        let structuredSummary;
        try {
          structuredSummary = JSON.parse(summaryOutput);
        } catch (e) {
          structuredSummary = {
            title: `Summary of ${file.name}`,
            sections: [
              { header: "Summary", content: summaryOutput || "No summary was generated.", page: 1 }
            ]
          };
        }
        updateProgress(fileId, 100);
        filesData[fileId].summary = structuredSummary;
    
        summaryButton.disabled = false;
        summaryButton.style.display = "inline-block";
        summaryButton.addEventListener('click', () => showSummaryPage(fileId));
      } catch (error) {
        console.error("Error processing PDF:", error);
        progressBar.style.background = "red";
        summaryButton.textContent = "Error Summarizing";
      }
    }
    
    /********************************************************************
     * PDF Rendering & Sticky Zoom Controls
     ********************************************************************/
    async function renderPDFPages(file, container, scale) {
      container.innerHTML = "";
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js";
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const viewport = page.getViewport({ scale: scale });
        const canvas = document.createElement("canvas");
        canvas.id = "pdf-page-" + i;
        canvas.style.marginBottom = "10px";
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext("2d");
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        container.appendChild(canvas);
      }
    }
    
    function navigateToPage(page) {
      const target = document.getElementById('pdf-page-' + page);
      if (target) target.scrollIntoView({ behavior: "smooth" });
      else alert("Page " + page + " not found.");
    }
    
    /********************************************************************
     * Content Formatting Helpers
     ********************************************************************/
    function formatContent(text) {
      const lines = text.split('\n');
      let html = '';
      let listOpen = false;
      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('- ') || line.startsWith('• ')) {
          if (!listOpen) { html += '<ul>'; listOpen = true; }
          let item = line.substring(2).trim();
          html += `<li>${item}</li>`;
        } else {
          if (listOpen) { html += '</ul>'; listOpen = false; }
          if (line) { html += `<p>${line}</p>`; }
        }
      });
      if (listOpen) { html += '</ul>'; }
      return html;
    }
    
    function generateFormattedHTML(summary) {
      let html = `
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${summary.title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          h2 { color: #001f3f; }
          h3 { color: #003366; }
          .section { margin-bottom: 20px; padding: 10px; border-bottom: 1px solid #ccc; }
          .analysis { color: #28a745; border: 1px solid #28a745; background: #f0fff0; padding: 10px; }
          p { line-height: 1.5; }
          ul { margin-left: 20px; }
        </style>
      </head>
      <body>
        <h2>${summary.title}</h2>
      `;
      summary.sections.forEach(sec => {
        if (sec.header.toLowerCase() === "analysis") {
          html += `<div class="section analysis">
                     <h3>${sec.header}</h3>
                     ${formatContent(sec.content)}
                   </div>`;
        } else {
          html += `<div class="section">
                     <h3>${sec.header}</h3>
                     ${formatContent(sec.content)}
                     ${sec.page ? `<p><em>Approximate page: ${sec.page}</em></p>` : ""}
                   </div>`;
        }
      });
      html += `</body></html>`;
      return html;
    }
    
    function downloadFormattedSummary(summary, format) {
      const htmlContent = generateFormattedHTML(summary);
      if (format === "word") {
        const blob = new Blob(['\ufeff', htmlContent], { type: 'application/msword' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "summary.doc";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    }
    
    /********************************************************************
     * Display Summary and PDF Viewer with Sticky Zoom Controls & Chatbot
     ********************************************************************/
    async function showSummaryPage(fileId) {
      const data = filesData[fileId];
      if (!data) return;
      document.querySelector("header").style.display = "none";
      currentDocumentOriginalText = data.originalText;
      
      mainPage.style.display = 'none';
      summaryPage.style.display = 'block';
      
      // Build left column with section summaries and the download button below them.
      let summaryLeftHTML = `<h2>${data.summary.title}</h2>`;
      data.summary.sections.forEach((section, index) => {
        const sectionClass = (section.header.toLowerCase() === "analysis") ? "section analysis" : "section";
        summaryLeftHTML += `
          <div class="${sectionClass}" data-index="${index}">
            <h3>${section.header}</h3>
            <div class="section-content">${formatContent(section.content)}</div>
            ${section.page ? `<p><em>Approximate page: ${section.page}</em></p>` : ""}
          </div>
        `;
      });
      summaryLeftHTML += `
        <div class="summary-controls">
          <button id="download-word" class="btn">Download as Word</button>
        </div>
      `;
      
      summaryContent.innerHTML = `
        <div class="summary-container">
          <div class="summary-left">${summaryLeftHTML}</div>
          <div class="summary-right">
            <div class="zoom-controls">
              <button id="zoom-in">Zoom In</button>
              <button id="zoom-out">Zoom Out</button>
            </div>
            <div id="pdf-viewer-container"></div>
          </div>
        </div>
      `;
      
      const pdfViewerContainer = document.getElementById('pdf-viewer-container');
      renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      
      const sections = summaryContent.querySelectorAll('.summary-left .section');
      sections.forEach((sectionElem, index) => {
        const secData = data.summary.sections[index];
        if (secData.header.toLowerCase() !== "analysis" && secData.page) {
          sectionElem.style.cursor = "pointer";
          sectionElem.addEventListener('click', () => {
            navigateToPage(secData.page);
          });
        } else {
          sectionElem.style.cursor = "default";
        }
      });
      
      document.getElementById('zoom-in').addEventListener('click', () => {
        pdfScale += 0.2;
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      document.getElementById('zoom-out').addEventListener('click', () => {
        if (pdfScale > 0.4) { pdfScale -= 0.2; }
        renderPDFPages(data.file, pdfViewerContainer, pdfScale);
      });
      
      pdfViewerContainer.addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
          e.preventDefault();
          if (e.deltaY < 0) {
            pdfScale += 0.1;
          } else {
            pdfScale = Math.max(0.1, pdfScale - 0.1);
          }
          renderPDFPages(data.file, pdfViewerContainer, pdfScale);
        }
      });
      
      setupDownloadButtons(data.summary);
      createChatbot();
      chatMemory = [];
    }
    
    function setupDownloadButtons(summary) {
      document.getElementById('download-word').onclick = () => { downloadFormattedSummary(summary, "word"); };
    }
    
    backButton.addEventListener('click', () => {
      summaryPage.style.display = 'none';
      mainPage.style.display = 'block';
      document.querySelector("header").style.display = "block";
      const chatbotToggle = document.getElementById('chatbot-toggle');
      const chatbotContainer = document.getElementById('chatbot-container');
      if (chatbotToggle) chatbotToggle.style.display = 'none';
      if (chatbotContainer) chatbotContainer.classList.remove("visible");
    });
    
    /********************************************************************
     * Chatbot Implementation with Memory and Document Context
     ********************************************************************/
    function createChatbot() {
      let chatbotToggle = document.getElementById('chatbot-toggle');
      let chatbotContainer = document.getElementById('chatbot-container');
      if (!chatbotToggle) {
        chatbotToggle = document.createElement('div');
        chatbotToggle.id = "chatbot-toggle";
        chatbotToggle.className = "chatbot-toggle";
        chatbotToggle.innerHTML = "💬";
        document.body.appendChild(chatbotToggle);
      }
      if (!chatbotContainer) {
        chatbotContainer = document.createElement('div');
        chatbotContainer.id = "chatbot-container";
        chatbotContainer.className = "chatbot-container";
        chatbotContainer.innerHTML = `
          <div id="chatbot-drag-handle" class="chatbot-drag-handle"></div>
          <div id="chatbot-header" class="chatbot-header">Document Chat</div>
          <div id="chatbot-messages" class="chatbot-messages"></div>
          <div class="chatbot-input-container">
            <input type="text" id="chatbot-input" placeholder="Type your message...">
            <button id="chatbot-send" class="btn">Send</button>
          </div>
        `;
        document.body.appendChild(chatbotContainer);
        makeChatbotResizable();
      }
      chatbotContainer.classList.remove("visible");
      chatbotToggle.style.display = "flex";
      
      if (!chatbotToggle.dataset.listenerAdded) {
        chatbotToggle.addEventListener('click', () => {
          if (chatbotContainer.classList.contains("visible")) {
            chatbotContainer.classList.remove("visible");
          } else {
            chatbotContainer.classList.add("visible");
          }
        });
        chatbotToggle.dataset.listenerAdded = "true";
      }
      
      const sendButton = document.getElementById('chatbot-send');
      const inputField = document.getElementById('chatbot-input');
      if (!sendButton.dataset.listenerAdded) {
        sendButton.addEventListener('click', sendChatMessage);
        sendButton.dataset.listenerAdded = "true";
      }
      if (!inputField.dataset.listenerAdded) {
        inputField.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') sendChatMessage();
        });
        inputField.dataset.listenerAdded = "true";
      }
    }
    
    function makeChatbotResizable() {
      const handle = document.getElementById('chatbot-drag-handle');
      const container = document.getElementById('chatbot-container');
      handle.addEventListener('mousedown', initDrag);
      function initDrag(e) {
        e.preventDefault();
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
      }
      function doDrag(e) {
        const rect = container.getBoundingClientRect();
        const newWidth = rect.right - e.clientX;
        const newHeight = rect.bottom - e.clientY;
        if(newWidth > 200) {
          container.style.width = newWidth + 'px';
        }
        if(newHeight > 150) {
          container.style.height = newHeight + 'px';
        }
      }
      function stopDrag(e) {
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
      }
    }
    
    function appendChatMessage(sender, text, extraClass="") {
      const messagesContainer = document.getElementById('chatbot-messages');
      const messageElem = document.createElement('div');
      messageElem.classList.add('chatbot-message', sender);
      if (extraClass) messageElem.classList.add(extraClass);
      messageElem.textContent = text;
      messagesContainer.appendChild(messageElem);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return messageElem;
    }
    
    function typeOutText(element, text, interval) {
      let index = 0;
      const timer = setInterval(() => {
        if (index < text.length) {
          element.textContent += text.charAt(index);
          index++;
        } else {
          clearInterval(timer);
        }
      }, interval);
    }
    
    async function sendChatMessage() {
      const inputElem = document.getElementById('chatbot-input');
      const message = inputElem.value.trim();
      if (!message) return;
      appendChatMessage("user", message);
      inputElem.value = "";
      
      chatMemory.push({ role: "user", content: message });
      if (chatMemory.length > 50) { chatMemory.shift(); }
      
      let contextText = currentDocumentOriginalText;
      
      const conversation = [
        { role: "system", content: "You are an AI assistant that only responds based on the following document (do not include any external information):\n" + contextText }
      ].concat(chatMemory);
      
      const totalTokenLimit = 20000;
      let conversationContent = conversation.map(msg => msg.content).join(" ");
      const conversationTokens = encode(conversationContent).length;
      const bufferTokens = 100;
      const maxCompletionTokens = Math.max(totalTokenLimit - conversationTokens - bufferTokens, 0);
      
      const typingElem = appendChatMessage("bot", "AI is typing...", "typing");
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
             "Content-Type": "application/json",
             "Authorization": `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: "o3-mini",
            messages: conversation,
            max_completion_tokens: maxCompletionTokens
          })
        });
        if (!response.ok) {
          typingElem.textContent = "Error: " + response.statusText;
          return;
        }
        const data = await response.json();
        const botReply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content 
                         ? data.choices[0].message.content.trim() 
                         : "I don't have an answer.";
        typingElem.remove();
        const botMessageElem = appendChatMessage("bot", "", "");
        typeOutText(botMessageElem, botReply, 20);
        chatMemory.push({ role: "assistant", content: botReply });
        if (chatMemory.length > 50) { chatMemory.shift(); }
      } catch (err) {
        typingElem.textContent = "Error: " + err.message;
      }
    }
  </script>
</body>
</html>
